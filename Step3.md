# Making SVGs colorful

To my knowledge, you can’t just slap on a ```color: blue``` to an ```<svg>``` tag. SVGs use the ```fill``` attribute for this sort of thing. If you have the colors ready to go, it should be no problem to just create a prop in your new component for a fill attribute:

```
<template>  
    <div v-html="require(`./../../svg/icon-${icon}.svg`)"></div>
</template>

<script>  
export default {  
      props: ['icon', 'fill'],

      mounted() {
        this.$el.firstChild.setAttribute('fill', this.fill);
    }
</script>
```

For me, this is no good. I’ve been relying on Tailwind’s built in colors and definitely don’t want to start hard-coding colors around my javascript.

At the end of the day, I really want to be able to add a class like ```text-green``` (which sets ```color: ...``` for an element in Tailwind) to the component and have the SVG automatically inherit that color. After writing a crazy hack to achieve this functionality I discover SVG offers this functionality out of the box with a property called: ```fill: currentColor```. To add to the spoils, Tailwind offers a CSS class called ```fill-current```. After deleting a bunch of crazy code that listens for changes to parent classes, get’s the computed color style and sets the fill of the SVG, I simply add this ```fill-current``` class and we are off to the races!

<b>The usage</b>

```
<svg-icon icon="trash" class="text-green"></svg-icon>
```

<b>The implementation</b>

```
<template>  
    <div v-html="require(`./../../svg/icon-${icon}.svg`)"></div>
</template>

<script>  
export default {  
    props: ['icon'],

    mounted() {
        this.$el.firstChild.classList.add('fill-current')
    }
}
</script>
```

Great, now that our SVGs are easily colorable, it’s time to tackle sizing and spacing.

# Sizing the SVGs

Apparently, sizing SVGs is a rabbit hole (see this CSS Tricks article to go down it). For now, I just need to get up and running with the basics: display the SVG inline and set the size according to the font-size. Later, I may want to size them explicitly and behave more like a ```block```, but for now, this will do just fine.

Out of the box, each SVG from Steve’s Heroicon UI pack is set to ```24px``` width and ```24px``` height. My first order of business is to strip the ```svg``` tag of these attributes.

```
this.$el.firstChild.removeAttribute('height')  
this.$el.firstChild.removeAttribute('width') 
```

After banging my head against my laptop stand, I came up with the following styles that will need to be applied to the <svg> tag for the desired behavior:

```
fill: currentColor;  
height: 1em;  
margin-top: -4px;  
vertical-align: middle;  
width: 1em;
```

I could set these properties individually in the ```mounted``` hook using javascript like ```this.$el.firstChild.style.height = ‘1em’```, but I’d rather not do that for a bunch of reasons that don’t actually matter (some vague sense of Right™️, syntax highlighting, others). For this, I choose to leverage Vue’s SFC ```<style>``` tag.

# Choosing a selector

So I know I want these styles in the ```<style>``` tag, but now I’m left with a new decision to make: what’s going to be my selector?

Before we explore selectors let’s first review the DOM structure of this component. It’s basically an ```<svg>``` tag inside a ```<div>``` tag.

```
<div>  
    <svg>
    </svg>
</div>
```

Remembering I can't just add a class to the svg tag, the easiest way to apply these styles is to either use javascript to add a class to the SVG tag or to add a class to the <div> like .svg-icon and use a nested selector like the following: .svg-icon svg.

My issue with this approach is that it forces me to think of a name. I’d rather explore options that avoid introducing a new name into the component.

My first idea is to use a nice clean svg selector and keep it from affecting the global styles with a scoped attribute like so:

```
<style scoped>  
    svg {
        fill: currentColor;
        height: 1em;
        margin-top: -4px;
        vertical-align: middle;
        width: 1em;
    }
</style>
```

Turns out the ```scoped``` attribute won’t apply to elements generated by the ```v-html``` directive. Luckily, I remember seeing this in the Vue docs and don’t have to bang my head against the monitor for too long.

After visiting the docs for alternatives, I read about a new Vue style tag option I’ve never seen before: ```module```. Apparently, if you add a ```module``` attribute to your ```<style>``` tag it will generate a unique selector for you and you can apply it to your DOM programmatically (using this fancy syntax: ```this.$style.{your-class-name}```). This seems like a good enough option, a little complex, but well documented and gives me that clean, Solid™️ feeling I’m after.

Here is the code:

```
// Style portion
<style module>  
.svg {
    fill: currentColor;
    height: 1em;
    // This margin makes me sooo saadddd
    // Someone please tell me why I need it or how I can get rid of it!
    margin-top: -4px;
    vertical-align: middle;
    width: 1em;
}
</style>

// In my mounted() hook:
this.$el.firstChild.classList.add(this.$style.svg)
```

Also, I want these SVGs to be inline by default, so I add the ```inline-block``` class to the root div:

```
<template>
    <div class="inline-block" v-html="require(`./../../svg/icon-${icon}.svg`)"></div>
</template>
```
